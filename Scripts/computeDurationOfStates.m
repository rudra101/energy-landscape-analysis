%duration of a state means the number of times it has occured consecutively while traversing a list(say, list of states generated by random walk). The mean and std are central tendencies of samples collected from complete list traversal.
%A non-empty statesOfInterest changes the behavior of the function. The function then tries to compute the consecutive stretch of any of the states present in statesOfInterest and condenses the time stretches for a dummy key, zero.
%this function can be used to calculate duration of major states by passing basinnumbers corresponding to random walk and the majorstate indices as statesOfInterest. 
function durationMap = computeDurationOfStates(simulatedStates, statesOfInterest)
	clear durationMap;
	durationMap = containers.Map('KeyType', 'double', 'ValueType','any');
	if length(statesOfInterest) == 0; %calculate duration for all states
		jj = 1; kk = 1;
		while jj <= length(simulatedStates); 
			state = simulatedStates(jj);
			kk = jj+1;
			while kk <=length(simulatedStates);  
			  if state ~= simulatedStates(kk);
			    break;
			  end
			  kk = kk + 1;
			end
			count = kk-jj;
			if ~isKey(durationMap, state);
			 durationMap(state) = [];
			end
			prev = durationMap(state);
			durationMap(state) = [prev, count]; %fill the duration array
			jj = kk; %move the seek forward
		end
	else %non-empty statesOfInterest. New behavior of function.
	       jj = 1; kk = 1;
		while jj <= length(simulatedStates); 
			state = simulatedStates(jj);
			if ~ismember(state, statesOfInterest);
				jj = jj + 1;
				continue;
			end
			kk = jj+1;
			while kk <= length(simulatedStates);  
			  if ~ismember(simulatedStates(kk), statesOfInterest);
			    break;
			  end
			  kk = kk + 1;
			end
			count = kk-jj;
			if ~isKey(durationMap, 0); %use 0 as dummy state
			 durationMap(0) = [];
			end
			prev = durationMap(0);
			durationMap(0) = [prev, count]; %fill the duration array
			jj = kk; %move the seek forward
		end
	
	end
end

